/**
 *              Textbook Example Program
 * Class:       Chapter04Exercise02.java
 * Purpose:     Test overloaded method that converts character sequences 
 *              representing hexadecimal values into those (decimal) values.
 *              Tests converting hex data file (hexdata.txt -> hexoutput.txt),
 *              converting number sequence to hex and back again,
 *              and converting user input.
 * 
 * @author:    Tyler Lucas
 * Student ID: 3305203
 * Date:       May 19, 2017
 * Version     1.2
 * 
 * Based on and References:
 * @see Introduction to Programming Using Java Version 7, by Eck, David J., 
 *      2014, p183: ch4, ex 2
 * @see <a href="https://en.wikipedia.org/w/index.php?title=Fibonacci_number&oldid=781470261">
 * Fibonacci number - Wikipedia</a>
 * 
 */

import java.io.FileNotFoundException;
import java.text.ParseException;

public class Chapter04Exercise02 {
    
    private static final boolean SKIP_FILE_CONVERSION = false;
    private static final boolean SKIP_FIBONACCI_CONVERSION = false;
    private static final boolean SKIP_USER_INPUT_CONVERSION = false;
    
    private static final boolean SUPPRESS_FILE_CONVERSION_OUTPUT = false;

    public static void main(String[] args) {
        
        if (!SKIP_FILE_CONVERSION) {
            // Read hexdata.txt, convert and write to hexoutput.txt
            System.out.println();
            System.out.println("Converting hexadecimal data in \"hexdata.txt\""
                    + " to decimal and writing to \"hexoutput.txt\".");
            try {
                parseHex("hexdata.txt","hexoutput.txt");
            } catch (FileNotFoundException e) {
                System.out.println(e);
            }
        }
        
        if (!SKIP_FIBONACCI_CONVERSION) {
            // Convert Fibonacci numbers to hex, then back, printing each step
            System.out.println();
            System.out.println("Fibonacci Sequence Conversion");
            System.out.printf(" %2s : %13s -> 0x%8s -> %13s%n",
                    "n","[input num.]","[hex]","[output num.]");
            for ( int i=0; i<=46; i++ ) {
                int fibonacciInt = fibonacci(i);
                String fibonacciHex = String.format("%8s",
                        Integer.toHexString(fibonacciInt)).replace(' ','0');
                int fibonacciHex2Int = parseHex(fibonacciHex);
                System.out.printf(" %02d : %,13d -> 0x%s -> %,13d%n",
                        i, fibonacciInt, fibonacciHex, fibonacciHex2Int);
            }
        }
        
        if (!SKIP_USER_INPUT_CONVERSION) {
            // Convert user input hex string
            TextIO.readStandardInput();
            System.out.println();
            System.out.println("User Input Conversion");
            System.out.print(" Hexadecimal input: 0x");
            int decValue = parseHex(TextIO.getlnString());
            System.out.print("Decimal conversion:   ");
            if (decValue > -1) { System.out.printf("%,d%n", decValue); }
            else { System.out.println("[invalid hex data]"); }
        }
    }
    
    /**
     * Generates Fibonacci number for given sequence index.
     * 
     * @param n     Index of the Fibonacci number, starting at {@code n=0}.
     *              Must be less than 52, as that Fibonacci number is too large 
     *              to return as {@code int}. Must be greater than 0.
     * @return      The Fibonacci number at index n.
     * @throws      IllegalArgumentException if n is less than 0 or greater
     *              than 51.
     * @since 1.1
     */
    static int fibonacci ( int n ) {
        if ( n < 0 ) {
            throw new IllegalArgumentException(
                    "Input is the Fibonacci sequence index, and must be "
                    + "greater than 0.");
        }
        else if ( n > 51 ) {
            throw new IllegalArgumentException(
                    "Fibonacci numbers for indices greater than 41 cannot "
                    + "be generated by this method.");
        }
        
        final double sqrt5 = Math.sqrt(5);
        final double goldenRatio = (1 + sqrt5)/2;    // approx 1.62
        final double silverRatio = (1 - sqrt5)/2;    // approx -0.62
        
        return (int)(Math.round(
                        ( Math.pow(goldenRatio, n) - Math.pow(silverRatio, n) )
                                /sqrt5
                ));
    }
    
    /**
     * Converts newline-separated hexadecimal values in text file to decimal,
     * writing output to file.
     * 
     * Precondition:    Input file should contain valid hex data, but it does
     *                  not have to (it writes {@code [invalid hex data]} for
     *                  invalid input data/lines. Need to include postfix
     *                  ({@code .txt} recommended).
     * Postcondition:   Output file is created or overwritten. Need to include
     *                  postfix ({@code .txt} recommended).
     * 
     * @param fin   Input filename. Absolute directory or relative to package.
     * @param fout  Output filename. Absolute directory or relative to package.
     * @throws FileNotFoundException if the input file causes an
     *              IllegalArgumentException to be thrown by TextIO.readFile().
     */
    static void parseHex( String fin, String fout ) throws FileNotFoundException {
        // Open hex data file.
        try {
            TextIO.readFile(fin);
        } catch (IllegalArgumentException e) {
            throw new FileNotFoundException("File \""+fin+"\" not found: " + e);
        }

        // Create new hex data file.
        try {
            TextIO.writeFile(fout);
        } catch ( IllegalArgumentException e ) {
            readErrorQuit(e);
        }

        // Loop over input file lines
        int lineNumber = 0, validHexLinesCount = 0;
        String strLine;
        while (true) {
            try{
                // Get line
                strLine = TextIO.getln();

                lineNumber++;

                // Print line
//                System.out.printf("Line %03d: %s", lineNumber, strLine);
            } catch ( IllegalArgumentException e ) {
                break;  // End of file.
            }

            // Parse hex value
            int hexFirstCharacterIndex = 0;
            if (strLine.length() > 1) {
                if (strLine.substring(0,2).compareToIgnoreCase("0x") == 0) {
                    hexFirstCharacterIndex = 2;
                }
                else if (strLine.charAt(0) == '#') {
                    hexFirstCharacterIndex = 1;
                }
            }
            String hexString = strLine.substring(hexFirstCharacterIndex);
            
            int hexValue = parseHex(hexString);

            if (!SUPPRESS_FILE_CONVERSION_OUTPUT) {
                // Print translation steps
                System.out.printf(
                        "Line %03d: %10s read as %8s and converted to (written as) ",
                        lineNumber, strLine, hexString);
                if (hexValue > -1) { System.out.println(hexValue); }
                else { System.out.println("[invalid hex data]"); }
            }
            
            // Write to file
            if (hexValue > -1) {
                TextIO.putln(hexValue);
                validHexLinesCount++;
            }
            else { TextIO.putln("[invalid hex data]"); }
        }

        // Print stats about hex translation
        System.out.println(validHexLinesCount + " of " + lineNumber
                + " values (lines) translated from hexadecimal to decimal "
                + "integers. (" + (lineNumber-validHexLinesCount)
                + " values were invalid.)");
    }
    
    /**
     * Translates input characters representing hexadecimal numbers into the
     * integer values of those numbers.
     * 
     * @param s     String object. Should represent a valid hexadecimal integer
     *              value, containing only characters that represent valid
     *              hexadecimal symbols [0-9a-fA-F]. Maximum 0x7FFFFFFF.
     * @return      Decimal (integer) value of hexadecimal value. Returns -1 if
     *              input does not represent a valid hexadecimal value, is
     *              empty, is mal-formed, is negative, or is over 0x7FFFFFFF.
     */
    static int parseHex( String s ) {
        
        if ( s.equals("") ) { return -1; }
        
        int hexValue = 0;

        try {
            int hexit = 0x1;     // like a digit
            for ( int i=s.length()-1; i>=0; i-- ) {
//                hexValue += hexit * hexValue( s.charAt(i) );
                hexValue = Math.addExact(
                        hexValue,
                        Math.multiplyExact( hexit, hexValue(s.charAt(i)) )
                );
                /* Do not check the following on the last loop, as it
                 * needlessly throws an ArithmeticException when converting
                 * any hexadecimal numbers 8 symbols long
                 * (0x00000000 to 0x7FFFFFFF). */
                if (i>0) { hexit = Math.multiplyExact(hexit, 0x10); }
            }
            
        } catch (ParseException | ArithmeticException e){
            return -1;
        }
        
        return hexValue;
    }
    
    /**
     * Translates input characters representing hexadecimal numbers into the
     * integer values of those numbers. Just like {@link hexValue(char)}, but
     * returns -1 instead of throwing ParseException.
     * 
     * @param c     char input, should represent hexadecimal value [0-9a-fA-F].
     * @return      Decimal (integer) value of hexadecimal value. Returns -1 if
     *              input does not represent a valid hexadecimal value.
     */
    static int parseHex( char c ) {
        try {
            return hexValue(c);
        } catch (ParseException e) {
            return -1;
        }
    }
        
    /**
     * Translates single character input representing hexadecimal numbers into
     * its integer value.
     * 
     * @param c     char
     * @return      Decimal (integer) value of hexadecimal value.
     * @throws      ParseException  when input char does not represent a
     *              hexadecimal value ([0-9a-fA-F]+).
     */
    static int hexValue( char c ) throws ParseException {
        int hexValue;
        if ( c >= '0' && c <= '9') hexValue = c - '0';
        else if ( c >= 'a' && c <= 'f' ) hexValue = c - 'a' + 10;
        else if ( c >= 'A' && c <= 'F' ) hexValue = c - 'A' + 10;
        else throw new ParseException(
                "Input character is not a valid hexadecimal value.",0);
        return hexValue;
    }
    
    /**
     * Prints exception String and quits all processes, to close untracked/additional
     * GUI processes such as when TextIO throws an exception trying to use a 
     * file. Created as per documentation in TextIO.
     * 
     * @param e An exception String to print out before {@code System.exit(1)}.
     */
    static void readErrorQuit(Exception e) {
        System.out.println( "File error: " + e);
        System.out.println("Quitting.");
        System.exit(1);
    }
}
