/**
 *              Textbook Example Program
 * Class:       Chapter04Exercise02.java
 * Purpose:     Test overloaded method that converts character sequences 
 *              representing hexadecimal values into those (decimal) values.
 *              Tests converting hex data file (hexdata.txt -> hexoutput.txt),
 *              array of Strings, and user input.
 * 
 * @author:    Tyler Lucas
 * Student ID: 3305203
 * Date:       May 19, 2017
 * Version     1.1
 * 
 * Based on and References:
 * @see Introduction to Programming Using Java Version 7, by Eck, David J., 
 *      2014, p183: ch4, ex 2
 * @see <a href="https://en.wikipedia.org/w/index.php?title=Fibonacci_number&oldid=781470261">
 * Fibonacci number - Wikipedia</a>
 * 
 */

import java.io.FileNotFoundException;
import java.text.ParseException;

public class Chapter04Exercise02 {
    
    private static final boolean SKIP_FILE_CONVERSION = false;
    private static final boolean SKIP_FIBONACCI_CONVERSION = false;
    private static final boolean SKIP_USER_INPUT_CONVERSION = false;
    
    private static final boolean SUPPRESS_FILE_CONVERSION_OUTPUT = false;

    public static void main(String[] args) {
        
        if (!SKIP_FILE_CONVERSION) {
            // Read hexdata.txt, convert and write to hexoutput.txt
            System.out.println();
            System.out.println("Converting hexadecimal data in \"hexdata.txt\""
                    + " to decimal and writing to \"hexoutput.txt\".");
            try {
                parseHex("hexdata.txt","hexoutput.txt");
            } catch (FileNotFoundException e) {
                System.out.println(e);
            }
        }
        
        if (!SKIP_FIBONACCI_CONVERSION) {
            // Convert Fibonacci numbers 1-46 to hex, then back, printing each step
            System.out.println();
            System.out.println("Fibonacci Sequence Conversion");
            for ( int i=0; i<=46; i++ ) {
                int fibonacciInt = fibonacci(i);
                String fibonacciHex = String.format("%8s",
                        Integer.toHexString(fibonacciInt)).replace(' ','0');
                int fibonacciHex2Int = parseHex(fibonacciHex);
                System.out.printf(" %02d : %,13d -> 0x%s -> %,13d%n",
                        i, fibonacciInt, fibonacciHex, fibonacciHex2Int);
            }
        }
        
        if (!SKIP_USER_INPUT_CONVERSION) {
            // Convert user input hex string
            TextIO.readStandardInput();
            System.out.println();
            System.out.println("User Input Conversion");
            System.out.print(" Hexadecimal input: 0x");
            int decValue = parseHex(TextIO.getlnString());
            System.out.printf("Decimal conversion:   %,d%n", decValue);
        }
    }
    
    /**
     * Generates Fibonacci number for given sequence index.
     * 
     * @param n     Index of the Fibonacci number, starting at {@code n=0}.
     *              Must be less than 52, as that Fibonacci number is too large 
     *              to return as {@code int}. Must be greater than 0.
     * @return      The Fibonacci number at index n.
     * @throws      IllegalArgumentException if n is less than 0 or greater
     *              than 51.
     * @since 1.1
     */
    static int fibonacci ( int n ) {
        if ( n < 0 ) {
            throw new IllegalArgumentException(
                    "Input is the Fibonacci sequence index, and must be "
                    + "greater than 0.");
        }
        else if ( n > 51 ) {
            throw new IllegalArgumentException(
                    "Fibonacci numbers for indices greater than 41 cannot "
                    + "be generated by this method.");
        }
        
        final double sqrt5 = Math.sqrt(5);
        final double goldenRatio = (1 + sqrt5)/2;    // approx 1.62
        final double silverRatio = (1 - sqrt5)/2;    // approx -0.62
        
        return (int)(Math.round(
                        ( Math.pow(goldenRatio, n) - Math.pow(silverRatio, n) )
                                /sqrt5
                ));
    }
    
    /**
     * Converts newline-separated hexadecimal values in text file to decimal,
     * writing output to file.
     * 
     * Precondition:    Input file should contain valid hex data, but it does
     *                  not have to (it writes {@code [invalid hex data]} for
     *                  invalid input data/lines. Need to include postfix
     *                  ({@code .txt} recommended).
     * Postcondition:   Output file is created or overwritten. Need to include
     *                  postfix ({@code .txt} recommended).
     * 
     * @param fin   Input filename. Absolute directory or relative to package.
     * @param fout  Output filename. Absolute directory or relative to package.
     * @throws FileNotFoundException if the input file causes an
     *              IllegalArgumentException to be thrown by TextIO.readFile().
     */
    static void parseHex( String fin, String fout ) throws FileNotFoundException {
        // Open hex data file.
        
        try {
            TextIO.readFile(fin);
        } catch (IllegalArgumentException e) {
            throw new FileNotFoundException("\""+fin+"\" not found: " + e);
        }

        // Create new hex data file.
        try {
            TextIO.writeFile(fout);
        } catch ( IllegalArgumentException e ) {
            readErrorQuit(e);
        }

        // Loop over input file lines
        int lineNumber = 0, validHexLinesCount = 0;
        String strLine;
        while (true) {
            try{
                // Get line
                strLine = TextIO.getln();

                lineNumber++;

                // Print line
//                System.out.printf("Line %03d: %s", lineNumber, strLine);
            } catch ( IllegalArgumentException e ) {
                break;  // End of file.
            }

            // Parse hex value
            int hexFirstCharacterIndex = 0;
            if (strLine.length() > 1) {
                if (strLine.substring(0,2).compareToIgnoreCase("0x") == 0) {
                    hexFirstCharacterIndex = 2;
                }
                else if (strLine.charAt(0) == '#') {
                    hexFirstCharacterIndex = 1;
                }
            }
            String hexString = strLine.substring(hexFirstCharacterIndex);
            
            int hexValue = parseHex(hexString);

            if (!SUPPRESS_FILE_CONVERSION_OUTPUT) {
                // Write to file and print translation steps
                System.out.printf(
                        "Line %03d: %10s read as %8s and converted to (written as) ",
                        lineNumber, strLine, hexString);
                if (hexValue > -1) { System.out.println(hexValue); }
                else { System.out.println("[invalid hex data]"); }
            }
            
            // Write to file
            if (hexValue > -1) {
                TextIO.putln(hexValue);
                validHexLinesCount++;
            }
            else { TextIO.putln("[invalid hex data]"); }
        }

        // Print stats about hex translation
//        System.out.println();
        System.out.println(validHexLinesCount + " of " + lineNumber
                + " values (lines) translated from hexadecimal to decimal "
                + "integers. (" + (lineNumber-validHexLinesCount)
                + " values were invalid.)");
    }

    /**
     * Translates input characters representing hexadecimal numbers into the
     * integer values of those numbers.
     * 
     * @param s     Array of String objects.
     * @return      Array of integers, the same size as the input array, each 
     *              the decimal (integer) value of the hexadecimal value.
     *              Return array element values set to -1 for those input array
     *              elements that do not represent a valid hexadecimal value.
     */
    static int[] parseHex( String[] s ) {
        int[] hexValues = new int[s.length];
        
        for ( int i=0; i<s.length; i++ ) {
            hexValues[i] = parseHex(s[i]);
        }
        
        return hexValues;
    }
    
    /**
     * Translates input characters representing hexadecimal numbers into the
     * integer values of those numbers.
     * 
     * @param sb    Array of StringBuilder objects.
     * @return      Array of integers, the same size as the input array, each 
     *              the decimal (integer) value of the hexadecimal value.
     *              Return array element values set to -1 for those input array
     *              elements that do not represent a valid hexadecimal value.
     */
    static int[] parseHex( StringBuilder[] sb ) {
        int[] hexValues = new int[sb.length];
        
        for ( int i=0; i<sb.length; i++ ) {
            hexValues[i] = parseHex(sb[i]);
        }
        
        return hexValues;
    }
    
    /**
     * Translates input characters representing hexadecimal numbers into the
     * integer values of those numbers.
     * 
     * @param c     Array of char.
     * @return      Array of integers, the same size as the input array, each 
     *              the decimal (integer) value of the hexadecimal value.
     *              Return array element values set to -1 for those input array
     *              elements that do not represent a valid hexadecimal value.
     */
    static int[] parseHex( char[] c ) {
        int[] hexValues = new int[c.length];
        
        for ( int i=0; i<c.length; i++ ) {
            hexValues[i] = parseHex(c[i]);
        }
        
        return hexValues;
    }
    
    /**
     * Translates input characters representing hexadecimal numbers into the
     * integer values of those numbers.
     * 
     * @param s     String object.
     * @return      Decimal (integer) value of hexadecimal value. Returns -1 if
     *              input does not represent a valid hexadecimal value.
     */
    static int parseHex( String s ) {
        int hexValue = 0, hexValueOld = 0;
        int hexit = 0x1;     // like a digit
        try {
            for ( int i=s.length()-1; i>=0; i-- ) {
//                hexValue += hexit * hexValue( s.charAt(i) );
                hexValue = addIntegersWithOverflowCheck(
                        hexValue,
                        hexit * hexValue(s.charAt(i))
                );
                hexit *= 0x10L;
            }
        } catch (ParseException | ArithmeticException e) {
            return -1;
        }
        return hexValue;
    }
    
    /**
     * Translates input characters representing hexadecimal numbers into the
     * decimal (integer) values of those numbers.
     * 
     * @param sb    StringBuilder object.
     * @return      Decimal (integer) value of hexadecimal value.
     *              Returns -1 if input does not represent a valid hexadecimal
     *              value.
     */
    static int parseHex( StringBuilder sb ) {
        int hexValue = 0;
        int hexit = 0x1;  // like a digit
        try {
            for ( int i=sb.length()-1; i>=0; i-- ) {
//                hexValue += hexit * hexValue( sb.charAt(i) );
                hexValue = addIntegersWithOverflowCheck(
                        hexValue,
                        hexit * hexValue(sb.charAt(i))
                );
                hexit *= 0x10L;
            }
        } catch (ParseException | ArithmeticException e) {
            return -1;
        }
        
        return hexValue;
    }
    
    /**
     * Translates input characters representing hexadecimal numbers into the
     * integer values of those numbers. Just like {@link hexValue(char)}, but
     * returns -1 instead of throwing ParseException.
     * 
     * @param c     char input, should represent hexadecimal value [0-9a-fA-F].
     * @return      Decimal (integer) value of hexadecimal value. Returns -1 if
     *              input does not represent a valid hexadecimal value.
     */
    static int parseHex( char c ) {
        try {
            return hexValue(c);
        } catch (ParseException e) {
            return -1;
        }
    }
        
    /**
     * Translates single character input representing hexadecimal numbers into
     * its integer value.
     * 
     * @param c     char
     * @return      Decimal (integer) value of hexadecimal value.
     * @throws      ParseException  when input char does not represent a
     *              hexadecimal value ([0-9a-fA-F]+).
     */
    static int hexValue( char c ) throws ParseException {
        int hexValue;
        if ( c >= '0' && c <= '9') hexValue = c - '0';
        else if ( c >= 'a' && c <= 'f' ) hexValue = c - 'a' + 10;
        else if ( c >= 'A' && c <= 'F' ) hexValue = c - 'A' + 10;
        else throw new ParseException(
                "Input character is not a valid hexadecimal value.",0);
        return hexValue;
    }
    
    /**
     * Adds two integers (int) and checks to see if the operation overflows.
     * 
     * @param a     int to add.
     * @param b     int to add.
     * @return      int a+b, if no exception.
     * @throws      ArithmeticException if a+b overflows (is greater than)
     *              {@code Integer.MAX_VALUE}.
     */
    static int addIntegersWithOverflowCheck( int a, int b ) throws ArithmeticException {
        long result = (long)a + b;
        if (result > Integer.MAX_VALUE) {
            throw new ArithmeticException("int overflow doing " + a + "+" + b);
        }
        else return (int)result;
    }
    
    /**
     * Quits on error using a file. {@code Uses System.exit(1)} to shut down GUI
     * processes that may have been opened in addition to the main process, as
     * per documentation in {@link java.TextIO}.
     */
    static void readErrorQuit(Exception e) {
        System.out.println( "File error: " + e);
        System.out.println("Quitting.");
        System.exit(1);
    }
}
